/**
  Copyright Â© 2023 COMPAN REF
  @file dmoc_main.cpp
  @brief Entry point
*/

#include <company_ref_dmo/company_ref_dmo_file.h>
#include <company_ref_main_apps/company_ref_app_options.h>
#include <company_ref_utils/company_ref_path_parser.h>
#include <Compan_logger/Compan_logger_sink_cout.h>

#include <company_ref_dmo/company_ref_dmo_file.h>
#include <company_ref_utils/company_ref_ini_config_file.h>

#include <dmo_tools_utils/Compan_dmo_ini_converter.h>
#include <dmo_tools_utils/Compan_dmo_meta_generator_class_def.h>
#include <dmo_tools_utils/Compan_dmo_meta_generator_class_impl.h>
#include <dmo_tools_utils/Compan_dmo_valueid_generator_class_def.h>
#include <dmo_tools_utils/Compan_dmo_valueid_generator_class_impl.h>

#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

#include <iostream>
#include <regex>
#include <string.h>

#include <functional>

using namespace Compan::Edge;

namespace {
int usage(char const* appname, int ret)
{
    std::cout << "Usage: " << appname << " [options]" << std::endl;
    std::cout << "Options:" << std::endl;
    std::cout << "  -h, --help                Display this message and exit" << std::endl;
    std::cout << "  -i, --ini                 Ini.cfg file path" << std::endl;
    std::cout << "                            Path can be wildcard and comma separated" << std::endl;
    std::cout << "  -d, --dmo                 Dmo file path" << std::endl;
    std::cout << "                            Path can be wildcard and comma separated" << std::endl;
    std::cout << "  -o, --out                 Output path for cpp/h files" << std::endl;
    std::cout << "  -n, --no-enums            Does not generate enum types in header file" << std::endl;
    std::cout << "  -m, --metadata            Creates metadata cpp/h files" << std::endl;
    std::cout << std::endl;
    return ret;
}

void generate_valueids(
        DmoContainer& dmoContainer,
        std::string const& baseId,
        std::string const& className,
        std::string const& microserviceName,
        boost::filesystem::path const& importName,
        boost::filesystem::path const& outPath,
        bool const generateEnumTypes)
{
    std::stringstream fileHeader;

    fileHeader << "// Generated by dmo compiler (dmoc)" << std::endl;
    fileHeader << "// **** DO NOT EDIT! ****" << std::endl;
    fileHeader << "// " << std::endl;
    fileHeader << "// source: " << importName << std::endl;
    fileHeader << "// " << std::endl;

    std::string fileNameBase = importName.stem().generic_string();
    fileNameBase += std::string("_value_ids");

    {
        boost::filesystem::path fileName(outPath / fileNameBase);
        fileName.replace_extension(".h");

        boost::filesystem::ofstream fileStrm(fileName);

        fileStrm << fileHeader.str() << std::endl;

        ValueIdGeneratorClassDef generator(dmoContainer);

        generator.baseId(baseId);
        generator.className(className);
        generator.microserviceName(microserviceName);
        generator.fileName(importName.stem().generic_string());
        generator.generateEnumTypes(generateEnumTypes);

        generator.generate(fileStrm);
    }

    {
        boost::filesystem::path fileName(outPath / fileNameBase);
        fileName.replace_extension(".cpp");

        boost::filesystem::ofstream fileStrm(fileName);

        fileStrm << fileHeader.str() << std::endl;

        ValueIdGeneratorClassImpl generator(dmoContainer);

        generator.className(className);
        generator.microserviceName(microserviceName);
        generator.fileName(importName.stem().generic_string());
        generator.baseId(baseId);
        generator.generateEnumTypes(generateEnumTypes);

        generator.generate(fileStrm);
    }
}

void generate_metadata(
        DmoContainer& dmoContainer,
        std::string const& className,
        std::string const& microserviceName,
        boost::filesystem::path const& importName,
        boost::filesystem::path const& outPath)
{
    std::stringstream fileHeader;

    fileHeader << "// Generated by dmo compiler (dmoc)" << std::endl;
    fileHeader << "// **** DO NOT EDIT! ****" << std::endl;
    fileHeader << "// " << std::endl;
    fileHeader << "// source: " << importName << std::endl;
    fileHeader << "// " << std::endl;

    std::string fileNameBase = importName.stem().generic_string();
    fileNameBase += std::string("_meta_data");

    {
        boost::filesystem::path fileName(outPath / fileNameBase);
        fileName.replace_extension(".h");

        boost::filesystem::ofstream fileStrm(fileName);

        fileStrm << fileHeader.str() << std::endl;

        MetaGeneratorClassDef generator(dmoContainer);

        generator.className(className);
        generator.microserviceName(microserviceName);
        generator.fileName(importName.stem().generic_string());

        generator.generate(fileStrm);
    }

    {
        boost::filesystem::path fileName(outPath / fileNameBase);
        fileName.replace_extension(".cpp");

        boost::filesystem::ofstream fileStrm(fileName);

        fileStrm << fileHeader.str() << std::endl;

        MetaGeneratorClassImpl generator(dmoContainer);

        generator.className(className);
        generator.microserviceName(microserviceName);
        generator.fileName(importName.stem().generic_string());

        generator.generate(fileStrm);
    }
}

void iniImport(
        boost::filesystem::path const& importPath,
        boost::filesystem::path const& outPath,
        bool const generateEnumTypes,
        bool const generateMetaData)
{
    IniConfigFile cfg;

    if (!cfg.read(importPath.generic_string())) {
        std::cout << "Error Reading: " << importPath << std::endl;
        return;
    }

    DmoContainer dmoContainer;

    DmoIniConverter converter(dmoContainer, cfg);

    converter.doImport();

    generate_valueids(
            dmoContainer,
            converter.baseId(),
            converter.className(),
            converter.microserviceName(),
            importPath,
            outPath,
            generateEnumTypes);
    if (generateMetaData)
        generate_metadata(dmoContainer, converter.className(), converter.microserviceName(), importPath, outPath);
}

void dmoImport(
        boost::filesystem::path const& importPath,
        boost::filesystem::path const& outPath,
        bool const generateEnumTypes,
        bool const generateMetaData)
{
    DmoContainer dmoContainer;
    if (!DmoFile::read(importPath.generic_string(), dmoContainer)) {
        std::cout << "Error Reading: " << importPath << std::endl;
        return;
    }

    generate_valueids(dmoContainer, "", "", "", importPath, outPath, generateEnumTypes);

    if (generateMetaData) generate_metadata(dmoContainer, "", "", importPath, outPath);
}

using ImportFunction =
        std::function<void(boost::filesystem::path const&, boost::filesystem::path const&, bool const, bool const)>;

void processPath(
        std::vector<std::string> const& paths,
        boost::filesystem::path const& outPath,
        bool const generateEnumTypes,
        bool const generateMetaData,
        ImportFunction const& importFunction)
{
    for (auto& path : paths) {

        // if comma separated - we have to parse them apart
        if (path.find(',') != std::string::npos) {

            PathParser::pathSplitString(
                    path,
                    [&outPath, &importFunction, &generateEnumTypes, &generateMetaData](std::string const& subPath) {
                        if (!boost::filesystem::exists(subPath)) std::cout << subPath << " not found" << std::endl;

                        std::cout << "Importing: " << subPath << std::endl;
                        importFunction(subPath, outPath, generateEnumTypes, generateMetaData);
                    });

            continue;
        }

        if (!boost::filesystem::exists(path)) std::cout << path << " not found" << std::endl;

        std::cout << "Importing: " << path << std::endl;
        importFunction(path, outPath, generateEnumTypes, generateMetaData);
    }
}

} // namespace

int main(int argc, char* argv[])
{
    CompanLoggerSinkCout sinkCout(false, 0);

    char const* appName = [&argv]() {
        auto p = strrchr(argv[0], '/');
        return (p ? ++p : argv[0]);
    }();

    std::vector<std::string> iniPaths;
    std::vector<std::string> dmoPaths;
    std::string outPath;

    AppOptionsParser appOptionsParser({
            {'i', "ini", true, false},
            {'d', "dmo", true, false},
            {'o', "out", true, true},
            {'n', "no-enums", false, false},
            {'m', "metadata", false, false},
            {'h', "help", false, false},
    });

    if (!appOptionsParser.parse(argc, argv)) return usage(appName, 1);

    if (appOptionsParser.has('h')) return usage(appName, 1);

    if (appOptionsParser.has('i')) iniPaths = appOptionsParser.multi('i');
    if (appOptionsParser.has('d')) dmoPaths = appOptionsParser.multi('d');
    if (appOptionsParser.has('o')) outPath = appOptionsParser.single('o');

    if ((iniPaths.empty() && dmoPaths.empty()) || outPath.empty()) return usage(appName, 1);

    bool const generateEnumTypes = !appOptionsParser.has('n');
    bool const generateMetaData = appOptionsParser.has('m');

    if (!iniPaths.empty()) {
        processPath(
                iniPaths,
                outPath,
                generateEnumTypes,
                generateMetaData,
                std::bind(
                        iniImport,
                        std::placeholders::_1,
                        std::placeholders::_2,
                        std::placeholders::_3,
                        std::placeholders::_4));
    }

    if (!dmoPaths.empty()) {
        processPath(
                dmoPaths,
                outPath,
                generateEnumTypes,
                generateMetaData,
                std::bind(
                        dmoImport,
                        std::placeholders::_1,
                        std::placeholders::_2,
                        std::placeholders::_3,
                        std::placeholders::_4));
    }

    return 0;
}
